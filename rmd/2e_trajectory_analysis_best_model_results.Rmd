---
title: "2c_trajectory_analysis_clean_results"
author: "Brit Henderson"
date: "4/3/2022"
output: html_document
---

```{r directories}
readdatdir <- "/data/share/xproject/Training/Practice/henderson/Dissertation/rda"
rdadir <- "/data/share/xproject/Training/Practice/henderson/Dissertation/rda"

```

# packages
```{r}
# Loads crimCV into the interpreter
library(crimCV)
library(tidyverse)
library(Hmisc)
library(GGally)
library(cowplot)
library(reshape2)

```

# Source Functions
```{r}
knitr::purl("rmd/0a_functions.Rmd")
source("rmd/0a_functions.R")
```

# load data
```{r}
analysis.dat1 <- readRDS(here::here("rda/trajectory_analysis_file.rds"))


```

# remove duplicates

```{r}
analysis.dat2 <- filter(analysis.dat1,fips_clean != "0")
#duplicated(analysis.dat1[,1:7])

#checkdup <- analysis.dat1[duplicated(analysis.dat1[,1:7])]

#check.dup <- analysis.dat2 %>% 
 # group_by(year, fips_clean) %>% 
 # mutate(dupe = n()>1) %>% filter(dupe==TRUE)


```

#restructure data to wide format so that each time period is a column, start with just young adult rate of arrest
```{r}
analysis.dat3<- analysis.dat2 %>% 
  pivot_wider(id_cols =fips_clean ,names_from = year, values_from = young_adult_rate, names_prefix = "year") %>% 
  arrange(fips_clean)  

analysis.dat4 <- analysis.dat3 %>% select(sort(names(analysis.dat3)))

```

#Use Paul Schneider's loop to determine best fit model based on AIC and BIC. Will check CVE as sensitivity check
```{r}

# Otherwise select your own data:
     test.data = analysis.dat4
    
  # reducing the size of the demo data set
    # test.data = test.data[1:100,] # looking at a subset 
  
  # Missing values need to be coded as negative values for crimCV
    test.data[is.na(test.data)] = -0.00001
  
  # data frame to matrix
    df = as.matrix(test.data[,-1])
    rownames(df) = test.data$fips_clean
#     df = test.dat2
  
  # resulting data set
    knitr::kable(head(df),format="markdown")
    
```    

## Re-run models
```{r}
  
#re-run loop that includes chosen model
#loop for n.cluster = c(1,1,1,1,1,6) and p.poly = c(1,2,3)

# GBTM CLUSTERING: crimCV
## set the grid of models to evaluate
  # Set: 
    n.cluster = c(1,1,1,1,1,6) # 1.which k's to evaluate, 
    p.poly = c(3) # 2. which p's to evaluate, 
    rcv = F # 3. do you want to run cross validation? T/F

## model evaluation
  
  # Run all models
    cv.eval.list = list()
    index = 0
    for(k in n.cluster)
    {
      sub.index = 0
      index = index + 1
          cv.eval.list[[index]] = list()
          names(cv.eval.list)[k] = paste("Groups",k,sep="_")
          for(p in p.poly)
            {
            print(cat("\n Running models for", n.cluster[k], "Groups, and",p.poly[p],"polynomials..."))
            cat("\n running k=",k,"poly=",p," \n")
            sub.index = sub.index + 1
            temp = crimCV(df,
                          ng = k,
                          dpolyp = p,
                          rcv = rcv,     
                          model = "ZIP"
                          )
        
            cv.eval.list[[index]][[sub.index]] = temp
        
            names(cv.eval.list[[index]])[sub.index] = paste("polynomial",p,sep="_")
            }
    }
    
## retrieve model evaluation results  
  
  # retrieve AIC, BIC and CV error for each of the models
  points.for.AIC.plot = points.for.BIC.plot = points.for.cv.plot = data.frame(x=NA,value=NA,cluster=NA)
  for(c in 1:length(cv.eval.list)){
    for(p in 1:length(cv.eval.list[[c]])){
      
  
      tryCatch({
          cv = ifelse(!is.null(cv.eval.list[[c]][[p]]$cv),cv.eval.list[[c]][[p]]$cv,NA)
          points.for.cv.plot = rbind(points.for.cv.plot,
                                     data.frame(x=p,value=cv ,cluster=c))
      }, error =function(e){})
      
      
      tryCatch({
          aic = ifelse(!is.null(cv.eval.list[[c]][[p]]$AIC),cv.eval.list[[c]][[p]]$AIC,NA)
          points.for.AIC.plot = rbind(points.for.AIC.plot,
                                      data.frame(x=p,value=aic,cluster=c))
      }, error =function(e){})
      
          tryCatch({
          bic = ifelse(!is.null(cv.eval.list[[c]][[p]]$BIC),cv.eval.list[[c]][[p]]$BIC,NA)
          points.for.BIC.plot = rbind(points.for.BIC.plot,
                                      data.frame(x=p,value=bic,cluster=c))
          }, error =function(e){})
      
    }}
  
  points.for.AIC.plot = points.for.AIC.plot[-1,]  
  points.for.BIC.plot = points.for.BIC.plot[-1,] 
  points.for.cv.plot = points.for.cv.plot[-1,]


```

#set parameters for model of choice
```{r} 
# Select k and p 
  k.set = 6
  p.set = 3
  
  
  
  # plot details
  y.axis.label = "Young Adult Arrests per County Year"
  x.axis.label = "Year"
  plot.title = "Young Adult Arrest Rate by Year"


## Retrieve data from your model of choice

  
  # retrieve the final model
  
    # select model
    ind.k = which(grepl(k.set,names(cv.eval.list)))
    ind.p = which(grepl(p.set,names(cv.eval.list[[ind.k]])))
    # retrieve participants membership
    gbtm.members = data.frame(ID =  rownames(df),
                                   cluster = apply(summary(cv.eval.list[[ind.k]][[ind.p]]),
                                                   1,
                                                   function(x)which(x ==max(x))))
    
    #save results
    saveRDS(gbtm.members,"rda/Intermediate/gbtm.members.rds")
   # gbtm.members <- readRDS("/data/share/xproject/Training/Practice/henderson/Dissertation/rda/Intermediate/gbtm.members.rds")
  
    members.per.cluster = data.frame(table(gbtm.members$cluster))
    
```

```{r}
## Plot estimated trajectories
 # gbtm.members <- readRDS("/data/share/xproject/Training/Practice/henderson/Dissertation/rda/Intermediate/gbtm.members.rds")
  
    members.per.cluster = data.frame(table(gbtm.members$cluster))
  
  # estimated trajectories
  
  modelled.list = plot(cv.eval.list[[ind.k]][[ind.p]],size=1,plot=F)
  modelled.list$time = modelled.list$time 
  
    model.plot.modelled = 
      ggplot(modelled.list) +
      geom_line(aes(x=time,y=value,col=cluster)) +
      scale_y_continuous(name=y.axis.label) +
      scale_x_continuous(name=x.axis.label) +
      ggtitle(plot.title) +
      scale_color_manual(lab=paste("Group ",members.per.cluster$Var1," (n=",members.per.cluster$Freq,")",sep=""),
                         values=c(2,3,4),
                         name="Estimated group trajectories") +
      theme_minimal()
    
    model.plot.modelled

## Retrieve group function terms

  
  # retrieve model function terms with intercept and * for p < .05
    long.test.dat = reshape2::melt(df)
    names(long.test.dat)  = c("ID","time","value")
    long.test.dat$time = as.numeric(gsub("t.","",long.test.dat$time))
    long.test.dat = merge(long.test.dat,gbtm.members,"ID")
    long.test.dat$cluster = as.factor(long.test.dat$cluster)
    
      #save results
    saveRDS(long.test.dat,"rda/Intermediate/long.test.dat.rds")
   # long.test.dat <- readRDS("/data/share/xproject/Training/Practice/henderson/Dissertation/rda/Intermediate/long.test.dat.rds")
  
```

#more plots
```{r}
  
    polynomial.model.results = summary(lm(value ~ -1+poly(time,p.set):cluster+cluster, long.test.dat))
    model.spec = round(polynomial.model.results$coefficients[,1],2)
    sig.model.specification = ifelse(polynomial.model.results$coefficients[,4]<0.05,"*"," ")
    model.spec = paste(model.spec,sig.model.specification,sep="")
    model.spec = formatC(model.spec)
    model.spec = matrix(data=model.spec, ncol=p.set+1)
    
    colnames(model.spec) = c("Intercept",paste("Polynomial",1:p.set))
    rownames(model.spec) = c(paste("Group",1:k.set))
    
    kable(model.spec,format="markdown")

## Plot average group trajectories
  
  # Retrieve observed group trajectories
    long.test.dat$value[long.test.dat$value<0] = NA
    long.test.dat.means = aggregate(value ~ cluster + time, long.test.dat, function(x) mean( x , na.rm = T))
    
    model.plot.from.data = ggplot(long.test.dat.means) +
      geom_line(aes(x=time,y=value,col=cluster)) +
      scale_y_continuous(name=y.axis.label) +
      scale_x_continuous(name=x.axis.label) +
      ggtitle(plot.title) +
      scale_color_manual(lab=paste("Group ",members.per.cluster$Var1," (n=",members.per.cluster$Freq,")",sep=""),
                         values=c(2,3,4),
                         name="Observed group trajectories") +
      theme_minimal()
    
    model.plot.from.data 

## Setup for complex plot

  # give names to clusters? 
  cluster.names = paste(
    c("First cluster", 
      "Second",
      "Third"),
      " (n=",format(as.numeric(members.per.cluster$Freq),digits=1),")",sep="")
  
  
  # set a y limits to have all sub plots on the same scale?
  set.y.limit = c(0,15000)


## Plot group and individual trajectories
  
  # Group average overview and individual trajectories
  
  pop.average.traj = aggregate(value ~time, long.test.dat, function(x) mean(x,na.rm=T))
  model.plot.modelled.plus.pop.average = 
      ggplot() +
    geom_line(data=modelled.list,aes(x=time,y=value,col=cluster,linetype="Estimated")) +
    geom_line(data=pop.average.traj,aes(x=time,y=value,col="Total",linetype="Average")) +  
      scale_y_continuous(name=y.axis.label) +
      scale_x_continuous(name=x.axis.label) +
      ggtitle(plot.title) +
      scale_color_manual(lab=c(paste("Group ",members.per.cluster$Var1," (n=",members.per.cluster$Freq,")",sep=""),
                               paste("Total", " (n=",sum(members.per.cluster$Freq),")",sep="")),
                         values=c(2:(k.set+1),1),
                         name="Estimated group trajectories") +
    scale_linetype_manual(lab=c("Average","Estimated"),values = c(2,1), name="")+
    guides(color = guide_legend(order = 1),
        linetype = guide_legend(order=0)) +
      theme_minimal()
  
  
    individual.plot.list = list()
    times.ex = unique(long.test.dat$time)
    for(i in 1:length(unique(long.test.dat$cluster))){
      individual.plot.list[[i]] = 
        ggplot() +
        theme_minimal() +
            geom_line(data=long.test.dat[long.test.dat$cluster==i,],
                      aes(x=time,y=value,group=ID,linetype="Average"),col=i+1,alpha=0.3,size=0.4) +
        geom_line(data=long.test.dat.means[long.test.dat.means$cluster==i,],
                      aes(x=time,y=value,linetype="Average"),col=i+1,size=1) +
         geom_line(data=modelled.list[modelled.list$cluster==i,],
                      aes(x=time,y=value,col=cluster,linetype="Estimate"),col=i+1,size=1) +
          scale_linetype_manual(lab=c("Average","Estimated"),values = c(2,1), name="") +
        theme(legend.position = "none") +
        ylab("") +
              # ggtitle(plot.titles.for.mega[i]) +
              coord_cartesian(ylim=set.y.limit) 
    }
    # individual.plot.list[[length(individual.plot.list)+1]] = get.legend
    
    gbtm.mega.plot = 
      plot_grid(model.plot.modelled.plus.pop.average+
                  coord_cartesian(ylim=set.y.limit),
                plot_grid(plotlist=individual.plot.list,ncol=round(k.set/2,0)),ncol=1,rel_heights = c(2,3))
    
    gbtm.mega.plot
    
```
```

#Try running A.W.'s loop on small number of obs
```{r}

results <- c()  #initializing a set of empty lists to store the seperate models
measures <- data.frame(cbind(groups=c(),llike=c(),AIC=c(),BIC=c(),CVE=c())) #nicer dataframe to check out model 
                                                                            
#model selection diagnostics
max <- 6 #this is the number of grouping solutions to check

#looping through models
for (i in 1:max){
    model <- crimCV(test.dat2,i,rcv=TRUE,dpolyp=2,dpolyl=3)
    results <- c(results, list(model))
    measures <- rbind(measures,data.frame(cbind(groups=i,llike=model$llike,
                                          AIC=model$AIC,BIC=model$BIC,CVE=model$cv)))
    #save(measures,results,file=paste0("Traj",as.character(i),".RData")) #save result
    }
#table of the model results
measures

#Re-run best model and output results to object
best.mod1 <- crimCV(test.dat2,5,rcv=TRUE, dpolyp =2, dpolyl =3)
plot(best.mod1)

```



# Checking out Andrew Wheeler's plotting code
"Now most effort seems to be spent on using model selection criteria to pick the number of groups, what may be called relative model comparisons. Once you pick the number of groups though, you should still be concerned with how well the model replicates the data at hand, e.g. absolute model comparisons. The graphs that follow help assess this. First we will use our helper functions to make three new objects. The first function, long_traj, takes the original model object, out1, as well as the original matrix data used to estimate the model, TO1adj. The second function, weighted_means, takes the original model object and then the newly created long_data longD. The third function, pred_means, just takes the model output and generates a data frame in wide format for plotting (it is the same underlying code for plotting the model).

```{r}
longD <- long_traj(model=best.mod1,data=test.dat2)
x <- weighted_means(model=best.mod1,long_data=longD)
pred <- pred_means(model=best.mod1)
#We can subsequently use the long data longD to plot the individual trajectories faceted by their assigned groups. I have an answer on cross validated that shows how effective this small multiple design idea can be to help disentangle complicated plots.


#plot of individual trajectories in small multiples by group
p <- ggplot(data=longD, aes(x=x,y=y,group=Ord)) + geom_line(alpha = 0.1) + facet_wrap(~GMax)
p 

#Plotting the individual trajectories can show how well they fit the predicted model, as well as if there are any outliers. You could get more fancy with jittering (helpful since there is so much overlap in the low counts) but just plotting with a high transparency helps quite abit. This second graph plots the predicted means along with the weighted means. What the weighted_means function does is use the posterior probabilities of groups, and then calculates the observed group averages per time point using the posterior probabilities as the weights.

#plot of predicted values + weighted means
p2 <- ggplot() + geom_line(data=pred, aes(x=x,y=pred_mean,col=as.factor(Group))) + 
                 geom_line(data=x, aes(x=x,y=w_mean,col=as.factor(Group))) + 
                geom_point(data=x, aes(x=x,y=w_mean,col=as.factor(Group))) +
                facet_grid(Group~.)
p2
```

Here you can see that the estimated trajectories are not a very good fit to the data. Pretty much each series has a peak before the predicted curve, and all of the series except for 2 don’t look like very good candidates for polynomial curves.



#predictions, weighted means, and non-weighted means
It ends up that often the weighted means are very nearly equivalent to the unweighted means (just aggregating means based on the classified group). In this example the predicted values are a colored line, the weighted means are a colored line with superimposed points, and the non-weighted means are just a black line. You can see the non-weighted means are almost exactly the same as the weighted ones. For group 3 you typically need to go to the hundredths to see a difference.

```{r}
nonw_means <- aggregate(longD$y,by=list(Group=longD$GMax,x=longD$x),FUN="mean")
names(nonw_means)[3] <- "y"

p3 <- p2 + geom_line(data=nonw_means, aes(x=x,y=y), col='black') + facet_wrap(~Group)
p3

#check out how close
nonw_means[nonw_means$Group==3,'y'] -  x[x$Group==3,'w_mean']
```



#superimpose predicted over ind trajectories
You can subsequently superimpose the predicted group means over the individual trajectories as well.
```{r}
pred$GMax <- pred$Group
p4 <- ggplot() + geom_line(data=pred, aes(x=x,y=pred_mean), col='red') + 
                 geom_line(data=longD, aes(x=x,y=y,group=Ord), alpha = 0.1) + facet_wrap(~GMax)
p4

```


#plot of maximum posterior probabilities

Two types of absolute fit measures I’ve seen advocated in the past are the average maximum posterior probability per group and the odds of correct classification. The occ function calculates these numbers given two vectors (one of the max probabilities and the other of the group classifications). We can get this info from our long data by just selecting a subset from one time period. Here the output at the console shows that we have quite large average posterior probabilities as well as high odds of correct classification. (Also updated to included the observed classified proportions and the predicted proportions based on the posterior probabilities. Again, these all show very good model fit.) Update: Jeff Ward sent me a note saying I should be using the predicted proportion in each group for the occ calculation, not the assigned proportion based on the max. post. prob. So I have updated to include the occ_pp column for this, but left the old occ column in as a paper trail of my mistake.
```{r}
occ(longD)
#A plot to accompany this though is a jittered dot plot showing the maximum posterior probability per group. You can here that groups 3 and 4 are more fuzzy, whereas 1 and 2 mostly have very high probabilities of group assignment.

subD <- longD[x==1,]
p5 <- ggplot(data=subD, aes(x=as.factor(GMax),y=PMax)) + geom_point(position = "jitter", alpha = 0.2)
p5
```


#scatterplot matrix
Remember that these latent class models are fuzzy classifiers. That is each point has a probability of belonging to each group. A scatterplot matrix of the individual probabilities will show how well the groups are separated. Perfect separation into groups will result in points hugging along the border of the graph, and points in the middle suggest ambiguity in the class assignment. You can see here that each group closer in number has more probability swapping between them.
```{r}
library(GGally)
options(scipen = 100)
sm <- ggpairs(data=subD, columns=4:7)
sm
```


#stacked area chart
And the last time series plot I have used previously is a stacked area chart.
```{r}
nonw_sum <- aggregate(longD$y,by=list(Group=longD$GMax,x=longD$x),FUN="sum")
names(nonw_sum)[3] <- "y"
p6 <- ggplot(data=nonw_sum, aes(x=x,y=y,fill=as.factor(Group))) + geom_area(position='stack')
p6
```

