---
title: "2b Trajectory Analysis"
author: "Brit Henderson"
date: "2/18/2022"
output: html_document
---

```{r directories}
readdatdir <- "/data/share/xproject/Training/Practice/henderson/Dissertation/rda"
rdadir <- "/data/share/xproject/Training/Practice/henderson/Dissertation/rda"

```

# packages
```{r}
Examples
# Loads crimCV into the interpreter
library(crimCV)
library(tidyverse)
library(Hmisc)

```


# load data
```{r}
analysis.dat1 <- readRDS(here::here("rda/trajectory_analysis_file.rds"))


```

# remove duplicates

```{r}
analysis.dat2 <- filter(analysis.dat1,fips_clean != "0")
#duplicated(analysis.dat1[,1:7])

#checkdup <- analysis.dat1[duplicated(analysis.dat1[,1:7])]

#check.dup <- analysis.dat2 %>% 
 # group_by(year, fips_clean) %>% 
 # mutate(dupe = n()>1) %>% filter(dupe==TRUE)


```

#restructure data to wide format so that each time period is a column, start with just young adult rate of arrest
```{r}
analysis.dat3<- analysis.dat2 %>% 
  pivot_wider(id_cols =fips_clean ,names_from = year, values_from = young_adult_rate, names_prefix = "year") %>% 
  arrange(fips_clean)  

analysis.dat4 <- analysis.dat3 %>% select(sort(names(analysis.dat3)))


#Turn data into matrix with ID variable omitted
analysis.mat1 <- as.matrix(analysis.dat4[,2:47]) #turn into matrix


summary(analysis.dat4) #check contents
analysis.mat1[1:10,1:5]
  
```

#try running code on small N of obs
```{r}
#test.dat <- as.data.frame(analysis.dat2[1:180,1:47])

#test.matrix <-as.double(test.dat[,1:46])
#test.matrix2 <- data.matrix(test.dat, rownames.force = NA)

#test.dat <- analysis.mat1[304:400,] #cannot handle missing values...
test.dat2 <- analysis.mat1[300:400,]

# Fit a 2 component ZIP(tau) model of degree 2. Here the CVE is not
# calculated and only ~1/4 of the data is used so that the code will
# run quickly enough to satisfy CRAN's package policies. To compute
# CVE run as: # out1<-crimCV(TO1adj,2,dpolyp=2,rcv=TRUE)
#out1<-crimCV(test.dat,2,dpolyp=2,init=5, rcv=FALSE)

# Next time, try replacing NA with -1
test.dat2[is.na(test.dat2)]<- -1

out1<-crimCV(test.dat2,2,dpolyp=2,init=5, rcv=TRUE)


```

#Try running A.W.'s loop on small number of obs
```{r}

results <- c()  #initializing a set of empty lists to store the seperate models
measures <- data.frame(cbind(groups=c(),llike=c(),AIC=c(),BIC=c(),CVE=c())) #nicer dataframe to check out model 
                                                                            
#model selection diagnostics
max <- 6 #this is the number of grouping solutions to check

#looping through models
for (i in 1:max){
    model <- crimCV(test.dat2,i,rcv=TRUE,dpolyp=2,dpolyl=3)
    results <- c(results, list(model))
    measures <- rbind(measures,data.frame(cbind(groups=i,llike=model$llike,
                                          AIC=model$AIC,BIC=model$BIC,CVE=model$cv)))
    #save(measures,results,file=paste0("Traj",as.character(i),".RData")) #save result
    }
#table of the model results
measures

#Re-run best model and output results to object
best.mod1 <- crimCV(test.dat2,5,rcv=TRUE, dpolyp =2, dpolyl =3)
plot(best.mod1)

```



# Checking out Andrew Wheeler's plotting code
"Now most effort seems to be spent on using model selection criteria to pick the number of groups, what may be called relative model comparisons. Once you pick the number of groups though, you should still be concerned with how well the model replicates the data at hand, e.g. absolute model comparisons. The graphs that follow help assess this. First we will use our helper functions to make three new objects. The first function, long_traj, takes the original model object, out1, as well as the original matrix data used to estimate the model, TO1adj. The second function, weighted_means, takes the original model object and then the newly created long_data longD. The third function, pred_means, just takes the model output and generates a data frame in wide format for plotting (it is the same underlying code for plotting the model).

```{r}
longD <- long_traj(model=best.mod1,data=test.dat2)
x <- weighted_means(model=best.mod1,long_data=longD)
pred <- pred_means(model=best.mod1)
#We can subsequently use the long data longD to plot the individual trajectories faceted by their assigned groups. I have an answer on cross validated that shows how effective this small multiple design idea can be to help disentangle complicated plots.


#plot of individual trajectories in small multiples by group
p <- ggplot(data=longD, aes(x=x,y=y,group=Ord)) + geom_line(alpha = 0.1) + facet_wrap(~GMax)
p 

#Plotting the individual trajectories can show how well they fit the predicted model, as well as if there are any outliers. You could get more fancy with jittering (helpful since there is so much overlap in the low counts) but just plotting with a high transparency helps quite abit. This second graph plots the predicted means along with the weighted means. What the weighted_means function does is use the posterior probabilities of groups, and then calculates the observed group averages per time point using the posterior probabilities as the weights.

#plot of predicted values + weighted means
p2 <- ggplot() + geom_line(data=pred, aes(x=x,y=pred_mean,col=as.factor(Group))) + 
                 geom_line(data=x, aes(x=x,y=w_mean,col=as.factor(Group))) + 
                geom_point(data=x, aes(x=x,y=w_mean,col=as.factor(Group))) +
                facet_grid(Group~.)
p2
```

Here you can see that the estimated trajectories are not a very good fit to the data. Pretty much each series has a peak before the predicted curve, and all of the series except for 2 don’t look like very good candidates for polynomial curves.



#predictions, weighted means, and non-weighted means
It ends up that often the weighted means are very nearly equivalent to the unweighted means (just aggregating means based on the classified group). In this example the predicted values are a colored line, the weighted means are a colored line with superimposed points, and the non-weighted means are just a black line. You can see the non-weighted means are almost exactly the same as the weighted ones. For group 3 you typically need to go to the hundredths to see a difference.

```{r}
nonw_means <- aggregate(longD$y,by=list(Group=longD$GMax,x=longD$x),FUN="mean")
names(nonw_means)[3] <- "y"

p3 <- p2 + geom_line(data=nonw_means, aes(x=x,y=y), col='black') + facet_wrap(~Group)
p3

#check out how close
nonw_means[nonw_means$Group==3,'y'] -  x[x$Group==3,'w_mean']
```



#superimpose predicted over ind trajectories
You can subsequently superimpose the predicted group means over the individual trajectories as well.
```{r}
pred$GMax <- pred$Group
p4 <- ggplot() + geom_line(data=pred, aes(x=x,y=pred_mean), col='red') + 
                 geom_line(data=longD, aes(x=x,y=y,group=Ord), alpha = 0.1) + facet_wrap(~GMax)
p4

```


#plot of maximum posterior probabilities

Two types of absolute fit measures I’ve seen advocated in the past are the average maximum posterior probability per group and the odds of correct classification. The occ function calculates these numbers given two vectors (one of the max probabilities and the other of the group classifications). We can get this info from our long data by just selecting a subset from one time period. Here the output at the console shows that we have quite large average posterior probabilities as well as high odds of correct classification. (Also updated to included the observed classified proportions and the predicted proportions based on the posterior probabilities. Again, these all show very good model fit.) Update: Jeff Ward sent me a note saying I should be using the predicted proportion in each group for the occ calculation, not the assigned proportion based on the max. post. prob. So I have updated to include the occ_pp column for this, but left the old occ column in as a paper trail of my mistake.
```{r}
occ(longD)
#A plot to accompany this though is a jittered dot plot showing the maximum posterior probability per group. You can here that groups 3 and 4 are more fuzzy, whereas 1 and 2 mostly have very high probabilities of group assignment.

subD <- longD[x==1,]
p5 <- ggplot(data=subD, aes(x=as.factor(GMax),y=PMax)) + geom_point(position = "jitter", alpha = 0.2)
p5
```


#scatterplot matrix
Remember that these latent class models are fuzzy classifiers. That is each point has a probability of belonging to each group. A scatterplot matrix of the individual probabilities will show how well the groups are separated. Perfect separation into groups will result in points hugging along the border of the graph, and points in the middle suggest ambiguity in the class assignment. You can see here that each group closer in number has more probability swapping between them.
```{r}
library(GGally)
options(scipen = 100)
sm <- ggpairs(data=subD, columns=4:7)
sm
```


#stacked area chart
And the last time series plot I have used previously is a stacked area chart.
```{r}
nonw_sum <- aggregate(longD$y,by=list(Group=longD$GMax,x=longD$x),FUN="sum")
names(nonw_sum)[3] <- "y"
p6 <- ggplot(data=nonw_sum, aes(x=x,y=y,fill=as.factor(Group))) + geom_area(position='stack')
p6
```

